<script lang="ts">
  import { runtimeStore } from "@rilldata/web-local/lib/application-state-stores/application-store";
  import { invalidateAfterReconcile } from "@rilldata/web-local/lib/svelte-query/invalidation";
  import { useQueryClient } from "@sveltestack/svelte-query";
  import { createForm } from "svelte-forms-lib";
  import { Button } from "../../../components/button";
  import Input from "../../../components/forms/Input.svelte";
  import {
    useRuntimeServicePutFileAndReconcile,
    useRuntimeServiceQuery,
    V1ReconcileResponse,
  } from "../../../runtime-client";
  import { fileArtifactsStore } from "../../entity-management/file-artifacts-store";
  import { EntityStatus } from "../../entity-management/types";
  import Spinner from "../../temp/Spinner.svelte";
  import FullPrompt from "./FullPrompt.svelte";

  export let modelName: string;

  const OPENAI_API_KEY = "YOUR_OPENAI_API_KEY";

  let schema: string;
  const schemaQuery = useRuntimeServiceQuery();

  $schemaQuery.mutate(
    {
      instanceId: $runtimeStore.instanceId,
      data: {
        sql: "select table_name, column_name, data_type from information_schema.columns where table_schema = 'main';",
        priority: 1,
      },
    },
    {
      onSuccess: (resp) => {
        // transform resp.data
        // input: {'table_name': TABLE_NAME, 'column_name': COLUMN_NAME, 'data_type': DATA_TYPE}[]
        // output: # Table_Name(column_name_1: DATA_TYPE, column_name_2: DATA_TYPE)\n # Table_Name(...)\n
        const schemaMap = resp.data.reduce((acc, row) => {
          const tableName = row["table_name"];
          const columnName = row["column_name"];
          const dataType = row["data_type"];
          if (acc[tableName]) {
            acc[tableName] += `, ${columnName}: ${dataType}`;
          } else {
            acc[tableName] = `# ${tableName}(${columnName}: ${dataType}`;
          }
          return acc;
        }, {});
        Object.keys(schemaMap).forEach((tableName) => {
          schemaMap[tableName] += ")";
        });
        const schemaHeader = "### DuckDB tables\n#\n";
        schema = schemaHeader + Object.values(schemaMap).join("\n");
      },
    }
  );

  let sql: string;
  $: query = `### ${$form["query"] ?? "[Your question here]"}`;
  const primer = "SELECT";
  $: prompt = schema + "\n#\n" + query + "\n" + primer;
  let isLoading: boolean;

  const { form, errors, handleSubmit } = createForm({
    initialValues: {
      prompt: "",
    },
    onSubmit: async () => {
      isLoading = true;
      const response = await fetch("https://api.openai.com/v1/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${OPENAI_API_KEY}`,
        },
        body: JSON.stringify({
          model: "code-davinci-002",
          prompt: prompt,
          temperature: 0,
          max_tokens: 150,
          top_p: 1,
          frequency_penalty: 0,
          presence_penalty: 0,
        }),
      });

      // Postprocess the response
      const data = await response.json();
      // add the primer back to the beginning of the response
      sql = primer + data.choices[0].text;
      // stop sql at first semicolon
      sql = sql.split(";")[0];
      // stop sql at first hashtag
      sql = sql.split("#")[0];
      // insert a newline before each FROM, WHERE, GROUP BY, ORDER BY, LIMIT
      // sql = sql.replace(/(FROM|WHERE|GROUP BY|ORDER BY|LIMIT)/g, "\n$1"); // TODO: this is only needed sometimes
      // prefix the sql with an informative comment
      sql = `-- SQL generated by GPT3\n-- Query: ${$form["query"]}\n-- Caution: Review and test the SQL before using it in production.\n\n${sql}`;
      useSql(sql);
      isLoading = false;
    },
  });

  const updateModel = useRuntimeServicePutFileAndReconcile();
  const queryClient = useQueryClient();

  function useSql(sql: string) {
    $updateModel.mutateAsync(
      {
        data: {
          instanceId: $runtimeStore.instanceId,
          path: `/models/${modelName}.sql`,
          blob: sql,
        },
      },
      {
        onSuccess: (resp: V1ReconcileResponse) => {
          fileArtifactsStore.setErrors(resp.affectedPaths, resp.errors);
          invalidateAfterReconcile(queryClient, $runtimeStore.instanceId, resp);
        },
        onError: (err) => {
          console.error(err);
        },
      }
    );
  }

  let showFullPromptModal = false;
  function openFullPromptModal() {
    showFullPromptModal = true;
  }
</script>

<div class="flex flex-col gap-y-4 flex-grow m-4">
  <div class="flex flex-col gap-y-2">
    Ask GPT3 a question about your data! GPT3 will pretend it's a data analyst
    and try to write the SQL query to answer your question. Your source schemata
    will be fed into the prompt.
  </div>
  <form
    id="openai-form"
    autocomplete="off"
    on:submit|preventDefault={handleSubmit}
  >
    <Input
      bind:value={$form["query"]}
      claimFocusOnMount
      error={$errors["query"]}
      id="query"
      label="Question"
      disabled={isLoading}
    />
    <div class="m-4" />
    <div class="flex flex-row gap-x-2">
      <Button type="secondary" on:click={openFullPromptModal}
        >See full prompt</Button
      >
      <Button
        type="primary"
        submitForm
        form="openai-form"
        disabled={!$form["query"] || isLoading}>Generate SQL</Button
      >
      {#if isLoading}
        <div class="flex flex-row gap-x-2 items-center">
          <Spinner size="1.5em" status={EntityStatus.Running} />
        </div>
      {/if}
    </div>
  </form>
</div>

{#if showFullPromptModal}
  <FullPrompt
    {prompt}
    on:close={() => {
      showFullPromptModal = false;
    }}
  />
{/if}
